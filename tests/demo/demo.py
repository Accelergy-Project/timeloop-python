"""
This is a demo file showing how to run and access the results of timeloop-python.
"""

# Imports QoL libraries.
import typing
from pathlib import Path

# Imports glob to access files.
import glob

# Imports the Engine to generate a Topology.
from bindings.model import Engine, Topology

# Imports BufferLevels for type hinting.
from bindings.buffer import BufferLevel

# Import utility functions to run the engine given a config directory.
from tests.util import run_evaluation

# Directory and path of all the config files.
config_dir: Path = Path("01-model-conv1d-2level")
paths: list[str] = [
    "arch/*.yaml",
    "map/conv1d-2level-os.map.yaml",
    "prob/*.yaml",
]

def gather_yaml_files(input_patterns: map) -> str:
    """Combines YAML files specified into one big string.

    @param input_patterns   The absolute paths of the files we want to access.

    @return                 The files we specified combined together.
    """
    # The return value namespace.
    yaml_str: str = ""

    # Iterates through all filepath patterns.
    pattern: str
    for pattern in input_patterns:
        # Calculates all files that match that pattern.
        fname: str
        for fname in glob.iglob(pattern):
            # Concatenates the file onto the string.
            with open(fname, "r", encoding="utf-8") as file:
                yaml_str += file.read() + "\n"
    return yaml_str


def gather_yaml_configs(rel_config_dir: Path, rel_paths: list[str]) -> str:
    """Combines together all the yaml config files into one string.

    @param rel_config_dir   The relative directory of the configs we want to
                            load in the Timeloop examples folder.
    @param rel_paths        The relative paths of all the config files within
                            the configs directory we specified.

    @return                 The combined string of all the YAML config files.
    """
    # Constructs the absolute path of the config directory.
    config_dir: Path = Path(__file__).parent / rel_config_dir
    # Constructs the absolute path of all the config files.
    paths: map = map(lambda p: str(config_dir / p), rel_paths)

    return gather_yaml_files(paths)


def run_evaluation(config_dir: Path, paths: list[str]) -> Engine:
    """Creates and runs Timeloop given a configuration directory and paths
    to the requisite YAML files.

    Outputs errors only through unittest asserts and print statements.

    @param config_dir   The directory containing the evaluation config settings.
    @param paths        The paths of all the requisite files in the directory.

    @return             The engine after it finished evaluation.
    """
    # Combined YAML string of all the config files.
    yaml_str = gather_yaml_configs(config_dir, paths)

    # Loads the YAML into Configuration settings.
    config: Config = Config(yaml_str, "yaml")
    # Pulls out the Config root node, containing all the config info.
    root: ConfigNode = config.getRoot()

    # Creates the workload specified by root.
    workload: Workload = Workload(root["problem"])
    # Creates the architecture specified by root.
    arch_specs: ArchSpecs = ArchSpecs(
        root["architecture"], "sparse_optimizations" in root
    )

    # Does accelergy load-ins if present.
    if "ERT" in root:
        arch_specs.parse_accelergy_ert(root["ERT"])
    if "ART" in root:
        arch_specs.parse_accelergy_art(root["ART"])

    # Creates the mapping off of the specifications and workload.
    mapping: Mapping = Mapping(root["mapping"], arch_specs, workload)
    # Creates SparseOptimizations off of settings.
    sparse_info: SparseOptimizationInfo = SparseOptimizationInfo(root, arch_specs)

    # Creates the evaluation engine with the specs.
    engine: Engine = Engine(arch_specs)
    # Runs the evaluator.
    engine.evaluate(mapping, workload, sparse_info)

    return engine


# Engine that is used to generate the Topology.
engine: Engine = run_evaluation(config_dir, paths)
# Topology containing the BufferLevels generated by Engine.
topology: Topology = engine.get_topology()
# BufferLevels constructed by Topology.
buffer_levels: list[BufferLevel] = topology.buffer_levels

# Goes through all the levels and prints out their stats using Python accessions.
level: BufferLevel
for level in buffer_levels:
    # Gets the stats of the level.
    stats: BufferLevel.Stats = level.stats
    # Collects all instance variable names of stats.
    var_names: list[str] = {
        var_name for var_name in dir(stats) if not callable(getattr(stats, var_name))
    } - {"__doc__", "__module__"}

    # Prints out every variable and its value.
    key: str
    for key in var_names:
        # Pulls the attribute from stats.
        attr: typing.Any = getattr(stats, key)
        print(f"{key}: {attr}")
